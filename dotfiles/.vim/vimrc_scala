" tabbar
let g:tagbar_type_scala = {
      \ 'ctagstype' : 'scala',
      \ 'sro'        : '.',
      \ 'kinds'     : [
      \ 'p:packages',
      \ 'T:types:1',
      \ 't:traits',
      \ 'o:objects',
      \ 'O:case objects',
      \ 'c:classes',
      \ 'C:case classes',
      \ 'm:methods',
      \ 'V:values:1',
      \ 'v:variables:1'
      \ ]
      \ }

fu! s:sbt_package_root()
  let savedir = getcwd()
  let dir = expand('%:p:h')
  exe "cd " . dir
  while (dir != '/')
    let configfile = dir . '/' . "build.sbt"
    if filereadable(configfile)
      break
    endif
    cd ..
    let dir = getcwd()
  endw
  exe "cd " savedir
  return dir
endf

fu! s:scala_test()
  let project_root = <SID>sbt_package_root()
  let project = split(project_root, '\/')[-1]
  let build_classpath = BuildClasspath()
  let class = FindClassToRun()
  let spec = <SID>find_scala_test_spec()
  if spec == ''
    let spec = <SID>find_scala_test_behavior()
  endif

  if(empty(spec))
    let cmd = "cd " . project_root . "; java -cp " . project . "-classpath.jar:" . build_classpath . " org.scalatest.tools.Runner -o -s " . class
  else
    let cmd = "cd " . project_root . "; java -cp " . project . "-classpath.jar:" . build_classpath . " org.scalatest.tools.Runner -o -s " . class . " -z '" . spec . "'"
  endif
  call RunCommand(cmd, 1)
endf

fu! s:find_bloop_dir()
  let savedir = getcwd()
  let dir = expand('%:p:h')
  exe "cd " . dir
  while (dir != '/')
    let configfile = dir . '/.bloop'
    if isdirectory(configfile)
      break
    endif
    cd ..
    let dir = getcwd()
  endw
  exe "cd " savedir
  return dir
endf

fu! s:bloop_build_classpath()
  let project_root = <SID>sbt_package_root()
  let project = split(project_root, '\/')[-1]
  let bloop_dir = <SID>find_bloop_dir()
  let bloop_classpath_dir = bloop_dir.'/.bloop/'.project.'/bloop-bsp-clients-classes'

  let impl_build_classes_directories=glob(bloop_classpath_dir.'/classes-Metals-*', 1, 1)
  let impl_build_classes_dir = ""
  let modify_time = 0
  for class_dir in impl_build_classes_directories
    if(modify_time < getftime(class_dir))
      let modify_time = getftime(class_dir)
      let impl_build_classes_dir = class_dir
    endif
  endfor

  let test_build_classes_directories=glob(bloop_classpath_dir.'/test-classes-Metals-*', 1, 1)
  let test_build_classes_dir = ""
  let modify_time = 0
  for class_dir in test_build_classes_directories
    if(modify_time < getftime(class_dir))
      let modify_time = getftime(class_dir)
      let test_build_classes_dir = class_dir
    endif
  endfor

  let it_build_classes_directories=glob(bloop_classpath_dir.'/it-classes-Metals-*', 1, 1)
  let it_build_classes_dir = ""
  let modify_time = 0
  for class_dir in it_build_classes_directories
    if(modify_time < getftime(class_dir))
      let modify_time = getftime(class_dir)
      let it_build_classes_dir = class_dir
    endif
  endfor

  return impl_build_classes_dir.':'.test_build_classes_dir.':'.it_build_classes_dir
endf

fu! s:open_sbt_pane(project_root)
  let sbt_pane = -1
  let panes = VimuxTmux("list-panes -F '#{pane_title}:#{pane_id}'")
  let panes = split(panes, "\n")
  for pane in panes
    let atts = split(pane, ":")
    let pane_title = atts[0]
    let pane_id = atts[1]
    let spec = match(pane_title, '.*;\s*sbt\|sbt')
    if spec == 0
      let sbt_pane = pane_id
    endif
  endfor
  if sbt_pane == -1
    let cmd = "cd " . a:project_root . "; sbt"
    call RunCommand(cmd, 1)
  endif
endfunction

fu! s:build_sbt_package()
  let package_root = <SID>sbt_package_root()
  call <SID>open_sbt_pane(package_root)
  let buildsystem = "set coverageEnabled := true; coverage; test; coverageAggregate"
  let tmux = 1
  call RunCommand(buildsystem, tmux)
endf

fu! s:get_package_name()
  let project_root = <SID>sbt_package_root()
  call <SID>open_sbt_pane(project_root)

  let package_line = search('^package ', 'Wnbc')
  if package_line ==# 0
    let package_name = ""
  else
    let package = getline(package_line)
    let package_name = split(package, ' ')[1]
  endif
  return package_name
endf

fu! s:get_class_name()
  let package_name = <SID>get_package_name()

  let path = expand('%:r')
  let class_name = split(path, '/')[-1]
  if package_name == ''
    let class = class_name
  else
    let class = package_name . '.' . class_name
  endif
  return class
endf

fu! s:sbt_run_current_file()
  let project_root = <SID>sbt_package_root()
  call <SID>open_sbt_pane(project_root)

  let class = <SID>get_class_name()
  let cmd = 'runMain ' . class
  call RunCommand(cmd, 1)
endf

fu! s:sbt_test_focus()
  let project_root = <SID>sbt_package_root()
  call <SID>open_sbt_pane(project_root)

  let class = <SID>get_class_name()
  let spec = <SID>find_scala_test_spec()
  if spec == ''
    let spec = <SID>find_scala_test_behavior()
  endif

  call <SID>run_sbt_test_only(class, spec)
endf

fu! s:sbt_test_current_file()
  let project_root = <SID>sbt_package_root()
  call <SID>open_sbt_pane(project_root)

  let class = <SID>get_class_name()
  call <SID>run_sbt_test_only(class, '')
endf

fu! s:find_scala_test_spec()
  " scala fun suite
  let test_line = search('\v\s*test\(\"(.+)\"\)\s*\{\s*', 'Wnbc')
  if test_line !=# 0
    let test = getline(test_line)
    let test_parts = matchlist(test, '\v\s*test\(\"(.+)\"\)\s*\{\s*')
    if (len(test_parts) >= 2)
      let test = test_parts[1]
      return test
    endif
  endif

  " scala fun spec
  let spec_line = search( '\v.*\"(.+)\"\s+in\s+\{\s*', 'Wnbc')
  let behavior_line = search( '\v\s*behavior of\s+"(.+)\"\s*', 'Wnbc')
  if spec_line ==# 0 && behavior_line ==# 0
    return ''
  endif
  if spec_line < behavior_line
    let spec_line = behavior_line
  endif

  let spec = getline(spec_line)
  let spec_parts = matchlist(spec, '\v.*\"(.+)\".*')
  if (len(spec_parts) >= 2)
    let spec = spec_parts[1]
  else
    let spec = ''
  endif
  return spec
endf

fu! s:find_scala_test_behavior()
  let spec_line = search( '\v\s*behavior of\s+"(.+)\"\s*', 'Wnbc')
  if spec_line ==# 0
    return ''
  endif

  let spec = getline(spec_line)
  let spec_parts = matchlist(spec, '\v\s*behavior of\s+"(.+)\"\s*')
  if (len(spec_parts) >= 2)
    let spec = spec_parts[1]
  else
    let spec = ''
  endif
  return spec
endf
 
fu! s:run_sbt_test_only(class, spec)
  let path = expand('%')
  let it = match(path, '.*src/it/.*')
  if it == -1
    let it = match(path, '.*integration/src/test/.*')
  endif
  if it == -1
    let cmd = 'testOnly '
  else
    let cmd = 'IntegrationTest / testOnly '
  endif
  if a:spec == ''
    let cmd = cmd . a:class
  else
    let cmd = cmd . a:class . ' -- -z "' . a:spec . '"'
  endif
  call RunCommand(cmd, 1)
endf

fu! s:run_scala_fix_only(file)
  let project_root = <SID>sbt_package_root()
  call <SID>open_sbt_pane(project_root)

  let cmd = 'scalafix --files ' . a:file
  call RunCommand(cmd, 1)
  exe 'e'
endf

autocmd filetype scala set shiftwidth=2          " Set indention level to be the same as softtabstop
autocmd filetype scala set softtabstop=2         " Why are tabs so big?  This fixes it
autocmd filetype scala set tabstop=2 shiftwidth=2      " a tab is two spaces (or set this to 4)
autocmd filetype scala nmap <silent> <Leader>fix :call <SID>run_scala_fix_only(expand('%'))<CR>
autocmd filetype scala nmap <silent> <Leader>tt :call <SID>sbt_test_focus()<CR>
autocmd filetype scala nmap <silent> <Leader>ta :call <SID>sbt_test_current_file()<CR>
autocmd filetype scala nmap <silent> <Leader>ut :call OpenTestFile('Spec', 'scala')<CR>
autocmd filetype scala nmap <silent> <Leader>ct :call NewTestFile('Spec', 'scala')<CR>
autocmd filetype scala nmap <silent> <Leader>run :call <SID>sbt_run_current_file()<CR>
autocmd filetype scala nmap <silent> <Leader>bb :call <SID>build_sbt_package()<CR>
autocmd BufRead,BufNewFile build.sbt nmap <silent> <Leader>bb :call <SID>build_sbt_package()<CR>
